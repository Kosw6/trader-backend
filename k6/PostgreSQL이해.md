## PostgreSQL이해

- PostgreSQL은 프로세스 기반 아키텍처로
  각 클라이언트 연결마다 전용 백엔드 프로세스를 생성하여 요청을 처리

- 프로세스 기반 VS 스레드 기반

| 구분             | PostgreSQL                                                                     | MySQL                                                                                                                                                                                                                                 |
| ---------------- | ------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 기본 아키텍쳐    | 프로세스 기반                                                                  | 쓰레드 기반                                                                                                                                                                                                                           |
| 연결방식         | 클라이언트 1명 <-> 백엔드 프로세스 1개 생성(OS 프로세스 단위로 독립 주소 공간) | 클라이언트 1명 ↔ 스레드 1개(하나의 프로세스 내 여러 스레드가 공유 메모리 사용) 생성                                                                                                                                                   |
| 프로세스 수 관리 | max_connections 개수만큼 OS 프로세스 생성됨                                    | max_connections 개수만큼 스레드 생성됨                                                                                                                                                                                                |
| 안정성           | 프로세스간 메모리 분리로 한 세션에 문제가 생겨도 다른 세션에 영향이 없음       | 모든 스레드가 하나의 주소 공간을 공유하기에 한 스레드의 메모리 오류가 전체 서비스로 전파 가능<br>ex)하나의 힙을 유지하기에 한 쓰레드가 버퍼 오버런을 일으키면 메타정보등이 망가져 다른 쓰레드의 접근시 시스템 다운등이 일어날 수 있음 |
| 동시성           | MVCC(Multi-Version Concurrency Control)                                        | InnoDB는 undo log를 활용한 MVCC → 구현 복잡도는 낮지만 내부 잠금(lock) 구조가 많음                                                                                                                                                    |
| 리소스 사용량    | 각 세션이 독립적인 프로세스이기에 메모리 사용량이 많음                         | 경량 쓰레드 기반이기에 메모리 효율이 좋음                                                                                                                                                                                             |
| 장점             | 데이터 일관성,안정성,동시성 제어 강함                                          | 메모리 효율성, 처리량, 단순성                                                                                                                                                                                                         |
| 단점             | 연결 수가 많으면 부담                                                          | 쓰레드간 오류 전파나 문제 발생시에 영향이 큼                                                                                                                                                                                          |
|                  |                                                                                |                                                                                                                                                                                                                                       |

### PostgreSQL 핵심 구성

| 구성 요소                                | 설명                                                                                                                            |
| ---------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| **Postmaster (서버 마스터 프로세스)**    | PostgreSQL의 메인 프로세스. 클라이언트 연결을 수락하고 각 세션마다 새로운 **Backend Process**를 생성함                          |
| **Backend Process (서버 세션 프로세스)** | 각 클라이언트의 SQL 요청을 실제로 수행하는 전용 프로세스. 세션이 끊기면 함께 종료됨                                             |
| **Shared Buffer**                        | 모든 백엔드가 공유하는 **데이터 캐시 영역** (DB의 `shared_buffers` 파라미터로 제어). 디스크 블록을 메모리에 캐싱하여 I/O를 줄임 |
| **WAL (Write-Ahead Log)**                | 트랜잭션 로그. 데이터 변경이 일어나기 전에 로그를 먼저 기록하여 **장애 복구** 보장                                              |
| **Background Writer / Checkpointer**     | Shared Buffer에서 변경된 데이터를 주기적으로 디스크에 flush함. 시스템 I/O 부하를 분산                                           |
| **Autovacuum Launcher / Worker**         | MVCC로 인해 생성된 **dead tuple**을 정리하는 백그라운드 프로세스                                                                |
| **Stats Collector / Logger**             | 통계와 모니터링 정보를 수집. Prometheus Exporter와 연동 시 이 데이터를 사용                                                     |

### MVCC (Multi-Version Concurrency Control)

- 버전 기반으로 작동하여 동시에 여러 트랜잭션이 같은 테이블을 읽고 쓰더라도, 서로 간섭하지 않게함
- 각 트랜잭션은 시작 시점의 데이터 상태를 스냅샷으로 기억 → 이후 다른 트랜잭션이 수정해도 내 트랜잭션은 일관된 상태만 읽음
- 각 튜플에는 생성 트랜잭션 ID(xmin), 삭제 트랜잭션 ID(xmax)가 함께 저장 -> 어느 트랜잭션이 볼 수 있는지 판단
- 더 이상 어떤 트랜잭션에서도 볼 수 없는 튜플 (이전 버전). → VACUUM이 제거해야 함

- ex) 트랜잭션 A(101),B(102)가 하나의 테이블을 볼 때에

1. A는 id=1번 튜플을 보고 있음 스냅샷 시점에 B가 없음
2. B는 id=1번을 수정하기 시작->xmax,xmin(102)
3. B가 1번 튜플의 이름을 변경하고 커밋함
4. A는 자신의 스냅샷에 B가 없기에 B가 커밋하기 전 데이터를 조회하게 됨

### VACCUM

- PostgreSQL은 데이터를 **물리적으로 즉시 삭제하지 않는다.**
  - 데이터가 `DELETE`되거나 `UPDATE`될 때, 기존 튜플은 dead tuple(죽은 버전)으로 표시만 되고, 새로운 버전이 생성된다.
  - `VACUUM`은 이러한 불필요한 튜플을 실제로 제거하는 역할을 한다.
- 먼저 각 튜플에는 `xmax`,`xmin`값을 가진다,
  - `xmax` : 이 튜플을 생성한 트랜잭션ID
  - `xmin` : 이 튜플을 삭제한 트랜잭션ID(수정의 경우도 포함)
- 튜플을 바로 지우기 보다 모든 트랜잭션이 볼 수 없는 튜플인지 확인하고 제거한다.
- PostgreSQL은 백엔드 프로세스들이 공유하는 전역 트랜잭션 ID 상태를 보고
  OldestXmin 값을 계산한다. <br>OldestXmin = 현재 살아 있는 가장 오래된 트랜잭션의 xmin -> 이 값 이전의 트랜잭션은 모두 커밋됨

#### 작동원리

1. 튜플의 xmax가 이미 커밋된 트랜잭션 && xmin이 OledstXmin보다 작음 = xmin보다 이전의 트랜잭션은 모두 커밋되었기에 해당 튜플은 삭제가 가능하다
2. 튜플의 xmax가 이미 커밋된 트랜잭션 && xmin이 OledstXmin보다 큼 = xmin이전의 트랜잭션이 해당 튜플을 보려고 하는 중 일 수도 있어 삭제 불가능

### 주요 파라미터

| 항목                                  | 권장/범위                            | 설명 & 팁                                                                                                  |
| ------------------------------------- | ------------------------------------ | ---------------------------------------------------------------------------------------------------------- |
| `max_connections`                     | **(Hikari 최대합 + 관리여유 30~50)** | 앱 인스턴스 합계가 이 값을 넘지 않도록. 많아지면 문맥전환↑. 많으면 **PgBouncer** 검토.                     |
| `shared_buffers`                      | RAM의 25% (Docker면 2~4GB 내)        | 가장 큰 캐시. 너무 크게 잡으면 OS 캐시 활용↓                                                               |
| `effective_cache_size`                | RAM의 50~75%                         | 플래너 힌트(실제 메모리 할당 아님).                                                                        |
| `work_mem`                            | 4~64MB/세션                          | 정렬/해시 등 쿼리 연산 메모리. 너무 크면 OOM 위험(세션별 × 동시쿼리수).                                    |
| `maintenance_work_mem`                | 256MB~1GB                            | VACUUM/REINDEX 등 유지보수.                                                                                |
| `wal_level`                           | `replica`                            | 기본.                                                                                                      |
| `max_wal_size`                        | 1~4GB+                               | 체크포인트 빈도 ↓                                                                                          |
| `checkpoint_timeout`                  | 5~15min                              | 너무 잦으면 I/O 스파이크.                                                                                  |
| `autovacuum`                          | on, 튜닝                             | `autovacuum_vacuum_scale_factor=0.1`, `autovacuum_analyze_scale_factor=0.05` 등 테이블 크기/변경률에 맞춤. |
| `statement_timeout`                   | 5s ~ 30s                             | 너무 긴 쿼리 차단. 애플리케이션 타임아웃 체인보다 **약간 길거나 비슷**하게.                                |
| `idle_in_transaction_session_timeout` | 30s ~ 120s                           | 트랜잭션 방치 세션 정리.                                                                                   |
| `tcp_keepalives_*`                    | 플랫폼 기본 또는 주기 단축           | 중간 장비 idle drop 방지.                                                                                  |
| JIT                                   | OLTP면 off도 고려                    | `jit=off`로 짧은 쿼리 지연 감소 가능.                                                                      |

## 🔗 참고

- [공식 문서 링크 HikariCP github](https://github.com/brettwooldridge/HikariCP/blob/dev/README.md#artifacts)
